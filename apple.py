import streamlit as st
from streamlit_drawable_canvas import st_canvas
from PIL import Image, ImageDraw, ImageFont
import io
import json
import copy
import uuid # For text item IDs
import os

# --- Configuration ---
# IMPORTANT: Download these font files and place them in a 'fonts' directory
# relative to your script, or provide absolute paths.
# Example: 'fonts/NotoSansKR-Regular.ttf'
AVAILABLE_FONTS = {
    "Noto Sans KR": "fonts/NotoSansKR-Regular.ttf",
    "Jua": "fonts/Jua-Regular.ttf",
    "Do Hyeon": "fonts/DoHyeon-Regular.ttf",
    "Nanum Gothic": "fonts/NanumGothic-Regular.ttf",
    "Nanum Myeongjo": "fonts/NanumMyeongjo-Regular.ttf",
    "Gowun Dodum": "fonts/GowunDodum-Regular.ttf",
    "Black Han Sans": "fonts/BlackHanSans-Regular.ttf",
    "Hahmlet": "fonts/Hahmlet-Regular.ttf",
    "Gaegu": "fonts/Gaegu-Regular.ttf",
    "Nanum Pen Script": "fonts/NanumPenScript-Regular.ttf",
    "Arial": "arial.ttf", # Common system font, often available
    "Default (Fallback)": "arial.ttf" # Fallback if others fail
}

# Create fonts directory if it doesn't exist, to avoid initial errors if user hasn't created it
if not os.path.exists("fonts"):
    os.makedirs("fonts")
    st.info("A 'fonts' directory has been created. Please place your .ttf font files there and update AVAILABLE_FONTS paths if necessary.")


def get_font_path(font_name, size=32): # Added size for default font
    """Gets the path to a font file, with fallback."""
    font_path_suggestion = AVAILABLE_FONTS.get(font_name)
    
    if font_path_suggestion and os.path.exists(font_path_suggestion):
        try:
            ImageFont.truetype(font_path_suggestion, size) # Test if font is valid
            return font_path_suggestion
        except IOError:
            st.warning(f"Could not load font '{font_name}' from '{font_path_suggestion}'. Trying fallback.")
            pass # Fall through to other fallbacks

    # Try Arial as a common system font
    arial_path = AVAILABLE_FONTS.get("Arial")
    if arial_path and os.path.exists(arial_path):
        try:
            ImageFont.truetype(arial_path, size)
            if font_name not in ["Arial", "Default (Fallback)"]: # Avoid warning if Arial was intended
                 st.warning(f"Font '{font_name}' not found or invalid. Using Arial as fallback.")
            return arial_path
        except IOError:
            pass # Arial also failed

    st.error(f"Font '{font_name}' and Arial fallback not found or invalid. Using Pillow's default font. Text rendering might be poor.")
    return None # Will lead to ImageFont.load_default()


# --- Session State Initialization ---
if "history" not in st.session_state:
    st.session_state.history = []
if "history_index" not in st.session_state:
    st.session_state.history_index = -1
if "current_text_items" not in st.session_state:
    st.session_state.current_text_items = [] 
if "current_drawing_json" not in st.session_state:
    st.session_state.current_drawing_json = {"objects": []} 
if "uploaded_image_pil" not in st.session_state:
    st.session_state.uploaded_image_pil = None
if "uploaded_file_name" not in st.session_state:
    st.session_state.uploaded_file_name = None
if "active_text_edit_id" not in st.session_state:
    st.session_state.active_text_edit_id = None
if "app_key_counter" not in st.session_state: 
    st.session_state.app_key_counter = 0
if "current_mode" not in st.session_state:
    st.session_state.current_mode = "ÌÖçÏä§Ìä∏" # Default mode
if "brush_color" not in st.session_state:
    st.session_state.brush_color = "#000000"
if "brush_size" not in st.session_state:
    st.session_state.brush_size = 10


# --- Helper Functions ---
def save_current_state():
    """Saves the current state (text items and drawing) to history."""
    st.session_state.history = st.session_state.history[:st.session_state.history_index + 1]
    
    state_snapshot = {
        "text_items": copy.deepcopy(st.session_state.current_text_items),
        "drawing_json": copy.deepcopy(st.session_state.current_drawing_json)
    }
    st.session_state.history.append(state_snapshot)
    st.session_state.history_index += 1

def load_state_from_history(index):
    """Loads a state from history by index."""
    if 0 <= index < len(st.session_state.history):
        snapshot = st.session_state.history[index]
        st.session_state.current_text_items = copy.deepcopy(snapshot["text_items"])
        st.session_state.current_drawing_json = copy.deepcopy(snapshot["drawing_json"])
        st.session_state.history_index = index
        st.session_state.active_text_edit_id = None 
        st.session_state.app_key_counter += 1 # Force re-render of components like canvas

def generate_image_with_text(base_image_pil, text_items_list):
    """Draws text items onto a copy of the base image."""
    if base_image_pil is None:
        img = Image.new("RGBA", (800, 600), (255, 255, 255, 255)) # Default blank white canvas
    else:
        img = base_image_pil.copy().convert("RGBA")

    draw = ImageDraw.Draw(img)
    for item in text_items_list:
        font_path = get_font_path(item["font"], item["size"])
        try:
            if font_path:
                font = ImageFont.truetype(font_path, item["size"])
            else: # Fallback to Pillow's default if get_font_path returned None
                font = ImageFont.load_default()
        except IOError:
            st.error(f"Error loading font: {item['font']} at path '{font_path}'. Using default.")
            font = ImageFont.load_default()

        text_content = item["content"]
        text_color = item["color"]
        
        # For rotation: draw on a separate transparent surface, rotate, then paste
        # Get text size using textbbox for better accuracy
        try:
            # Calculate bounding box on a dummy draw object to handle multi-line potential
            # For single line, (0,0) anchor is fine.
            text_bbox = draw.textbbox((0,0), text_content, font=font, anchor="lt") 
            text_width = text_bbox[2] - text_bbox[0]
            text_height = text_bbox[3] - text_bbox[1]
        except Exception as e: # Catch any error during textbbox calculation
            st.warning(f"Could not calculate text dimensions for '{text_content[:20]}...': {e}. Skipping text item.")
            continue


        if text_width <= 0 or text_height <= 0: continue # Skip empty or invalid text

        txt_img = Image.new('RGBA', (text_width, text_height), (0, 0, 0, 0)) # Transparent background
        txt_draw = ImageDraw.Draw(txt_img)
        txt_draw.text((0, 0), text_content, font=font, fill=text_color, anchor="lt")

        rotated_txt_img = txt_img.rotate(float(item["angle"]), expand=True, resample=Image.BICUBIC)
        
        paste_x = item["x"] - rotated_txt_img.width // 2
        paste_y = item["y"] - rotated_txt_img.height // 2
        
        img.paste(rotated_txt_img, (paste_x, paste_y), rotated_txt_img)
            
    return img

# --- UI Layout ---
st.set_page_config(layout="wide", page_title="Ïù∏Ïä§ÌÉÄÌà∞ Ìé∏ÏßëÍ∏∞")
st.title("üé® Ïù∏Ïä§ÌÉÄÌà∞ Ìé∏ÏßëÍ∏∞ (Streamlit Version)")
st.markdown("Í∞ÑÎã®Ìïú Ïù∏Ïä§ÌÉÄÌà∞ Ïù¥ÎØ∏ÏßÄ Ìé∏ÏßëÍ∏∞ÏûÖÎãàÎã§. Ïù¥ÎØ∏ÏßÄÎ•º Ïò¨Î¶¨Í≥† ÌÖçÏä§Ìä∏Î•º Ï∂îÍ∞ÄÌïòÍ±∞ÎÇò Í∑∏Î¶ºÏùÑ Í∑∏Î†§Î≥¥ÏÑ∏Ïöî!")

# --- Sidebar Controls ---
with st.sidebar:
    st.header("üõ†Ô∏è ÎèÑÍµ¨")
    
    uploaded_file = st.file_uploader("1. Ïù¥ÎØ∏ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞:", type=["png", "jpg", "jpeg"], key=f"uploader_{st.session_state.app_key_counter}")
    if uploaded_file:
        if st.session_state.uploaded_file_name != uploaded_file.name:
            try:
                st.session_state.uploaded_image_pil = Image.open(uploaded_file)
                st.session_state.uploaded_file_name = uploaded_file.name
                st.session_state.current_text_items = []
                st.session_state.current_drawing_json = {"objects": []}
                save_current_state() 
                st.session_state.app_key_counter += 1
                st.rerun()
            except Exception as e:
                st.error(f"Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ Ïó¨Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§: {e}")
                st.session_state.uploaded_image_pil = None
                st.session_state.uploaded_file_name = None


    st.session_state.current_mode = st.radio(
        "2. Î™®Îìú ÏÑ†ÌÉù:", 
        ("ÌÖçÏä§Ìä∏", "Î∏åÎü¨Ïãú"), 
        index=0 if st.session_state.current_mode == "ÌÖçÏä§Ìä∏" else 1, 
        key=f"mode_radio_{st.session_state.app_key_counter}"
    )

    # Text Mode Controls
    if st.session_state.current_mode == "ÌÖçÏä§Ìä∏":
        st.subheader("üìù ÌÖçÏä§Ìä∏ ÏÑ§Ï†ï")
        with st.form(key="new_text_form"):
            new_text_content = st.text_input("ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©:")
            col1, col2 = st.columns(2)
            with col1:
                new_text_font = st.selectbox("Ìè∞Ìä∏:", list(AVAILABLE_FONTS.keys()), index =0)
                new_text_x = st.number_input("X Ï¢åÌëú:", value=100, step=10, format="%d")
            with col2:
                new_text_size = st.slider("ÌÅ¨Í∏∞:", 10, 150, 32) # Increased max size
                new_text_y = st.number_input("Y Ï¢åÌëú:", value=100, step=10, format="%d")
            new_text_color = st.color_picker("ÏÉâÏÉÅ:", "#000000")
            new_text_angle = st.slider("ÌöåÏ†Ñ Í∞ÅÎèÑ (-180¬∞ ~ 180¬∞):", -180.0, 180.0, 0.0, 1.0) # Finer control for angle

            submitted_new_text = st.form_submit_button("ÌÖçÏä§Ìä∏ Ï∂îÍ∞Ä")
            if submitted_new_text and new_text_content:
                st.session_state.current_text_items.append({
                    "id": str(uuid.uuid4()), "content": new_text_content, 
                    "x": new_text_x, "y": new_text_y, "font": new_text_font, 
                    "size": new_text_size, "color": new_text_color, "angle": new_text_angle
                })
                save_current_state()
                st.session_state.app_key_counter += 1
                st.rerun()
        
        st.markdown("---")
        st.subheader("üìú ÌÖçÏä§Ìä∏ Î™©Î°ù & Ìé∏Ïßë")
        if not st.session_state.current_text_items:
            st.caption("Ï∂îÍ∞ÄÎêú ÌÖçÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.")

        for i, item in reversed(list(enumerate(st.session_state.current_text_items))): # Show newest first
            item_id = item["id"]
            with st.expander(f"ÌÖçÏä§Ìä∏ {len(st.session_state.current_text_items) - i}: {item['content'][:20]}"):
                if st.session_state.active_text_edit_id == item_id:
                    with st.form(key=f"edit_form_{item_id}"):
                        edit_content = st.text_input("ÎÇ¥Ïö©:", value=item["content"], key=f"edit_content_{item_id}")
                        c1, c2 = st.columns(2)
                        edit_x = c1.number_input("X:", value=item["x"], step=10, key=f"edit_x_{item_id}", format="%d")
                        edit_y = c2.number_input("Y:", value=item["y"], step=10, key=f"edit_y_{item_id}", format="%d")
                        
                        default_font_index = 0
                        try:
                            default_font_index = list(AVAILABLE_FONTS.keys()).index(item["font"])
                        except ValueError: # If font not in keys, use default
                            pass
                        edit_font = st.selectbox("Ìè∞Ìä∏:", list(AVAILABLE_FONTS.keys()), index=default_font_index, key=f"edit_font_{item_id}")
                        
                        edit_size = st.slider("ÌÅ¨Í∏∞:", 10, 150, value=item["size"], key=f"edit_size_{item_id}")
                        edit_color = st.color_picker("ÏÉâÏÉÅ:", value=item["color"], key=f"edit_color_{item_id}")
                        edit_angle = st.slider("ÌöåÏ†Ñ:", -180.0, 180.0, value=float(item["angle"]), step=1.0, key=f"edit_angle_{item_id}")

                        col_update, col_cancel = st.columns(2)
                        if col_update.form_submit_button("‚úîÔ∏è ÏóÖÎç∞Ïù¥Ìä∏", use_container_width=True):
                            st.session_state.current_text_items[i] = {
                                "id": item_id, "content": edit_content, "x": edit_x, "y": edit_y,
                                "font": edit_font, "size": edit_size, "color": edit_color, "angle": edit_angle
                            }
                            st.session_state.active_text_edit_id = None
                            save_current_state()
                            st.session_state.app_key_counter += 1
                            st.rerun()
                        if col_cancel.form_submit_button("‚úñÔ∏è Ï∑®ÏÜå", type="secondary", use_container_width=True):
                            st.session_state.active_text_edit_id = None
                            st.rerun()
                else:
                    st.markdown(f"**ÎÇ¥Ïö©**: `{item['content']}`")
                    st.markdown(f"**ÏúÑÏπò**: `({item['x']}, {item['y']})`, **ÌÅ¨Í∏∞**: `{item['size']}`, **Í∞ÅÎèÑ**: `{item['angle']:.1f}¬∞`")
                    st.markdown(f"**Ìè∞Ìä∏**: `{item['font']}`, **ÏÉâÏÉÅ**: <span style='color:{item['color']}; font-weight:bold;'>{item['color']}</span>", unsafe_allow_html=True)
                    
                    col_edit, col_delete = st.columns(2)
                    if col_edit.button("‚úèÔ∏è Ìé∏Ïßë", key=f"edit_{item_id}", use_container_width=True):
                        st.session_state.active_text_edit_id = item_id
                        st.rerun()
                    if col_delete.button("üóëÔ∏è ÏÇ≠Ï†ú", key=f"delete_{item_id}", type="primary", use_container_width=True):
                        st.session_state.current_text_items.pop(i)
                        st.session_state.active_text_edit_id = None # Ensure no lingering edit state
                        save_current_state()
                        st.session_state.app_key_counter += 1
                        st.rerun()

    # Brush Mode Controls
    elif st.session_state.current_mode == "Î∏åÎü¨Ïãú":
        st.subheader("üñåÔ∏è Î∏åÎü¨Ïãú ÏÑ§Ï†ï")
        st.session_state.brush_color = st.color_picker("Î∏åÎü¨Ïãú ÏÉâÏÉÅ:", st.session_state.brush_color, key="brush_color_picker")
        st.session_state.brush_size = st.slider("Î∏åÎü¨Ïãú ÌÅ¨Í∏∞:", 1, 100, st.session_state.brush_size, key="brush_size_slider") # Increased max size
        if st.button("Î∏åÎü¨ÏãúÎßå ÏßÄÏö∞Í∏∞", key="clear_brush_btn", use_container_width=True):
            st.session_state.current_drawing_json = {"objects": []} # Reset drawing
            save_current_state()
            st.session_state.app_key_counter += 1
            st.rerun()
    
    st.markdown("---")
    st.subheader("üé® ÏûëÏóÖ Í¥ÄÎ¶¨")
    col_hist1, col_hist2 = st.columns(2)
    with col_hist1:
        can_undo = st.session_state.history_index > 0
        if st.button("‚Ü©Ô∏è Ïã§Ìñâ Ï∑®ÏÜå", disabled=not can_undo, use_container_width=True):
            load_state_from_history(st.session_state.history_index - 1)
            st.rerun()
    with col_hist2:
        can_redo = st.session_state.history_index < len(st.session_state.history) - 1
        if st.button("‚Ü™Ô∏è Îã§Ïãú Ïã§Ìñâ", disabled=not can_redo, use_container_width=True):
            load_state_from_history(st.session_state.history_index + 1)
            st.rerun()

    if st.button("üóëÔ∏è Î™®Îëê ÏßÄÏö∞Í∏∞", key="clear_all_btn", type="primary", use_container_width=True):
        st.session_state.uploaded_image_pil = None 
        st.session_state.uploaded_file_name = None
        st.session_state.current_text_items = []
        st.session_state.current_drawing_json = {"objects": []}
        st.session_state.history = [] # Clear history too
        st.session_state.history_index = -1
        save_current_state() # Save this cleared state as the new initial state
        st.session_state.app_key_counter += 1
        st.rerun()

    # Prepare image for canvas
    image_with_text_pil = generate_image_with_text(
        st.session_state.uploaded_image_pil,
        st.session_state.current_text_items
    )
    
    st.markdown("---")
    st.subheader("üíæ Ï†ÄÏû•")
    # This will be updated after canvas rendering if there's drawing output
    final_image_for_download_pil = image_with_text_pil 


# --- Main Canvas Area ---
main_col1, main_col2 = st.columns([3, 1]) # Canvas column, Info column

with main_col1:
    st.markdown("### üñºÔ∏è Ï∫îÎ≤ÑÏä§")
    canvas_display_width = 700 # Max width for canvas display
    canvas_display_height = 500 # Max height for canvas display

    if image_with_text_pil:
        img_w, img_h = image_with_text_pil.size
        aspect_ratio = img_w / img_h
        
        # Calculate display dimensions maintaining aspect ratio
        if aspect_ratio > (canvas_display_width / canvas_display_height): # Wider than max aspect
            display_w = canvas_display_width
            display_h = int(canvas_display_width / aspect_ratio)
        else: # Taller than max aspect or fits
            display_h = canvas_display_height
            display_w = int(canvas_display_height * aspect_ratio)
        
        # Ensure display dimensions are at least 1x1
        display_w = max(1, display_w)
        display_h = max(1, display_h)

        resized_image_for_canvas = image_with_text_pil.resize((display_w, display_h), Image.Resampling.LANCZOS)
    else: 
        display_w, display_h = canvas_display_width, canvas_display_height
        resized_image_for_canvas = Image.new("RGBA", (display_w, display_h), (230, 230, 230, 255)) 

    canvas_key = f"drawable_canvas_{st.session_state.app_key_counter}"
    
    # Determine drawing mode for canvas: 'freedraw' for brush, 'transform' otherwise (though transform won't affect PIL text)
    # 'transform' allows selecting/moving objects drawn by st_canvas itself.
    canvas_drawing_mode = "freedraw" if st.session_state.current_mode == "Î∏åÎü¨Ïãú" else "transform"

    canvas_result = st_canvas(
        fill_color="rgba(255, 165, 0, 0.0)",  # Transparent fill for shapes drawn by canvas toolbar
        stroke_width=st.session_state.brush_size if st.session_state.current_mode == "Î∏åÎü¨Ïãú" else 2,
        stroke_color=st.session_state.brush_color if st.session_state.current_mode == "Î∏åÎü¨Ïãú" else "#0000FF", # Blue for transform mode shapes
        background_color="rgba(230, 230, 230, 1)", # Canvas element background if image is smaller
        background_image=resized_image_for_canvas, 
        update_streamlit=True, 
        height=display_h,
        width=display_w,
        drawing_mode=canvas_drawing_mode,
        initial_drawing=st.session_state.current_drawing_json if st.session_state.current_drawing_json else {"objects": []}, # Ensure valid JSON
        key=canvas_key,
        display_toolbar=True # Show the small toolbar of st_canvas for shapes/canvas-undo
    )

    # Process canvas results
    if canvas_result and canvas_result.image_data is not None:
        final_image_for_download_pil = Image.fromarray(canvas_result.image_data.astype('uint8'), 'RGBA')

        if canvas_result.json_data is not None and \
           canvas_result.json_data != st.session_state.current_drawing_json:
            if st.session_state.current_mode == "Î∏åÎü¨Ïãú": 
                st.session_state.current_drawing_json = canvas_result.json_data
                save_current_state()
                # No rerun here, update_streamlit=True handles it.

    # Download Button (moved to sidebar, but uses final_image_for_download_pil which is updated after canvas)
    if final_image_for_download_pil:
        buf = io.BytesIO()
        final_image_for_download_pil.save(buf, format="PNG")
        byte_im = buf.getvalue()
        st.sidebar.download_button(
            label="Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• (PNG)",
            data=byte_im,
            file_name="instatoon_streamlit.png",
            mime="image/png",
            use_container_width=True
        )
    else:
        st.sidebar.caption("Ï†ÄÏû•Ìï† Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.")

with main_col2:
    st.markdown("### ‚ÑπÔ∏è Ï†ïÎ≥¥")
    st.caption(f"**ÌòÑÏû¨ Î™®Îìú**: {st.session_state.current_mode}")
    if st.session_state.uploaded_image_pil:
        orig_w, orig_h = st.session_state.uploaded_image_pil.size
        st.caption(f"**ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞**: {orig_w}x{orig_h}")
    st.caption(f"**Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞**: {display_w}x{display_h}")
    st.caption(f"**ÌÖçÏä§Ìä∏ Í∞ùÏ≤¥ Ïàò**: {len(st.session_state.current_text_items)}")
    
    num_drawing_objects = 0
    if st.session_state.current_drawing_json and "objects" in st.session_state.current_drawing_json:
        num_drawing_objects = len(st.session_state.current_drawing_json["objects"])
    st.caption(f"**Î∏åÎü¨Ïãú Í∞ùÏ≤¥ Ïàò**: {num_drawing_objects}")
    
    st.markdown("---")
    st.markdown("#### ÏÇ¨Ïö© Î∞©Î≤ï:")
    st.markdown("""
    1.  **Ïù¥ÎØ∏ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞**: Ìé∏ÏßëÌï† Ïù¥ÎØ∏ÏßÄÎ•º ÏóÖÎ°úÎìúÌï©ÎãàÎã§.
    2.  **Î™®Îìú ÏÑ†ÌÉù**: 'ÌÖçÏä§Ìä∏' ÎòêÎäî 'Î∏åÎü¨Ïãú' Î™®ÎìúÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.
        * **ÌÖçÏä§Ìä∏ Î™®Îìú**: Í∏ÄÍº¥, ÌÅ¨Í∏∞, ÏÉâÏÉÅ, ÏúÑÏπò, ÌöåÏ†ÑÏùÑ ÏÑ§Ï†ïÌïòÍ≥† ÌÖçÏä§Ìä∏Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. Î™©Î°ùÏóêÏÑú Í∏∞Ï°¥ ÌÖçÏä§Ìä∏Î•º Ìé∏ÏßëÌïòÍ±∞ÎÇò ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.
        * **Î∏åÎü¨Ïãú Î™®Îìú**: Î∏åÎü¨Ïãú ÏÉâÏÉÅÍ≥º ÌÅ¨Í∏∞Î•º ÏÑ§Ï†ïÌïòÍ≥† Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶ºÏùÑ Í∑∏Î¶ΩÎãàÎã§. `streamlit-drawable-canvas`Ïùò ÏûêÏ≤¥ Ìà¥Î∞îÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÎèÑÌòïÏùÑ Í∑∏Î¶¥ ÏàòÎèÑ ÏûàÏäµÎãàÎã§.
    3.  **ÏûëÏóÖ Í¥ÄÎ¶¨**: 'Ïã§Ìñâ Ï∑®ÏÜå', 'Îã§Ïãú Ïã§Ìñâ', 'Î™®Îëê ÏßÄÏö∞Í∏∞' Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.
    4.  **Ï†ÄÏû•**: ÏôÑÏÑ±Îêú Ïù¥ÎØ∏ÏßÄÎ•º PNG ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìúÌï©ÎãàÎã§.
    """)
    st.markdown("---")
    st.markdown("##### Ìè∞Ìä∏ ÏïàÎÇ¥:")
    st.markdown("Ïù¥ Ïï±ÏùÄ ÏßÄÏ†ïÎêú Í≤ΩÎ°úÏóêÏÑú Ìè∞Ìä∏ ÌååÏùº(.ttf)ÏùÑ Î°úÎìúÌïòÎ†§Í≥† ÏãúÎèÑÌï©ÎãàÎã§. `fonts` Ìè¥ÎçîÏóê ÏõêÌïòÎäî Ìè∞Ìä∏Î•º ÎÑ£Í≥† `AVAILABLE_FONTS` Î≥ÄÏàòÎ•º ÏàòÏ†ïÌïòÏÑ∏Ïöî. Ìè∞Ìä∏ Î°úÎìú Ïã§Ìå® Ïãú Í≤ΩÍ≥†Í∞Ä ÌëúÏãúÎê† Ïàò ÏûàÏúºÎ©∞, Í∏∞Î≥∏ Ìè∞Ìä∏Î°ú ÎåÄÏ≤¥Îê©ÎãàÎã§.")


# Debugging info (optional, uncomment to use)
# with st.sidebar.expander("Debug Info"):
#     st.json(st.session_state.current_text_items, expanded=False)
#     st.json(st.session_state.current_drawing_json, expanded=False)
#     st.write(f"History Index: {st.session_state.history_index} / {len(st.session_state.history)-1 if st.session_state.history else -1}")
#     st.write(f"App Key Counter: {st.session_state.app_key_counter}")
#     st.write(f"Uploaded File Name: {st.session_state.uploaded_file_name}")
#     st.write(f"Active Edit ID: {st.session_state.active_text_edit_id}")
